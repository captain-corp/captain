
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">codeinstyle.io/captain/cli/user.go (9.1%)</option>
				
				<option value="file1">codeinstyle.io/captain/cli/validation.go (85.7%)</option>
				
				<option value="file2">codeinstyle.io/captain/db/db.go (0.0%)</option>
				
				<option value="file3">codeinstyle.io/captain/handlers/admin.go (0.0%)</option>
				
				<option value="file4">codeinstyle.io/captain/handlers/auth.go (0.0%)</option>
				
				<option value="file5">codeinstyle.io/captain/handlers/posts.go (0.0%)</option>
				
				<option value="file6">codeinstyle.io/captain/handlers/routes.go (0.0%)</option>
				
				<option value="file7">codeinstyle.io/captain/main.go (0.0%)</option>
				
				<option value="file8">codeinstyle.io/captain/middleware/auth.go (0.0%)</option>
				
				<option value="file9">codeinstyle.io/captain/utils/crypto.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cli

import (
        "fmt"
        "log"

        "codeinstyle.io/captain/db"
        "github.com/spf13/cobra"
        "golang.org/x/crypto/bcrypt"
        "golang.org/x/term"
)

func getValidInput(prompt string, validator func(string) error) string <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                var input string
                fmt.Print(prompt)
                fmt.Scanln(&amp;input)

                if err := validator(input); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error: %v. Please try again.\n", err)
                        continue</span>
                }
                <span class="cov8" title="1">return input</span>
        }
}

func getValidPassword(prompt string) string <span class="cov0" title="0">{
        fmt.Println("\nPassword requirements:")
        fmt.Println("- At least 8 characters long")
        fmt.Println("- At least one uppercase letter")
        fmt.Println("- At least one lowercase letter")
        fmt.Println("- At least one number")
        fmt.Println("- At least one special character (!@#$%^&amp;*(),.?\":{}|&lt;&gt;)")
        fmt.Println()

        for </span><span class="cov0" title="0">{
                fmt.Print(prompt)
                passwordBytes, _ := term.ReadPassword(0)
                password := string(passwordBytes)
                fmt.Println() // Add newline after password input

                if err := validatePassword(password); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error: %v. Please try again.\n", err)
                        continue</span>
                }
                <span class="cov0" title="0">return password</span>
        }
}

func CreateUser(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        firstName := getValidInput("First Name: ", validateFirstName)
        lastName := getValidInput("Last Name: ", validateLastName)
        email := getValidInput("Email: ", validateEmail)
        password := getValidPassword("Password: ")

        hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)

        database := db.InitDB()
        user := db.User{
                FirstName: firstName,
                LastName:  lastName,
                Email:     email,
                Password:  string(hashedPassword),
        }

        if err := database.Create(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create user: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("User created successfully")</span>
}

func UpdateUserPassword(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        email := getValidInput("Email: ", validateEmail)

        database := db.InitDB()
        var user db.User
        if err := database.Where("email = ?", email).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                fmt.Println("User not found")
                return
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                fmt.Print("Old Password: ")
                oldPasswordBytes, _ := term.ReadPassword(0)
                fmt.Println()

                if err := bcrypt.CompareHashAndPassword([]byte(user.Password), oldPasswordBytes); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Incorrect password. Please try again.")
                        continue</span>
                }
                <span class="cov0" title="0">break</span>
        }

        <span class="cov0" title="0">newPassword := getValidPassword("New Password: ")

        for </span><span class="cov0" title="0">{
                fmt.Print("Confirm Password: ")
                confirmBytes, _ := term.ReadPassword(0)
                fmt.Println()
                confirmPassword := string(confirmBytes)

                if newPassword != confirmPassword </span><span class="cov0" title="0">{
                        fmt.Println("Passwords don't match. Please try again.")
                        newPassword = getValidPassword("New Password: ")
                        continue</span>
                }
                <span class="cov0" title="0">break</span>
        }

        <span class="cov0" title="0">hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
        user.Password = string(hashedPassword)

        if err := database.Save(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update password: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Password updated successfully")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cli

import (
        "fmt"
        "regexp"
        "strings"
)

func validateFirstName(firstName string) error <span class="cov8" title="1">{
        if len(firstName) &lt; 1 || len(firstName) &gt; 255 </span><span class="cov8" title="1">{
                return fmt.Errorf("first name must be between 1 and 255 characters")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateLastName(lastName string) error <span class="cov0" title="0">{
        if len(lastName) &lt; 1 || len(lastName) &gt; 255 </span><span class="cov0" title="0">{
                return fmt.Errorf("last name must be between 1 and 255 characters")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateEmail(email string) error <span class="cov8" title="1">{
        emailRegex := regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,}$`)
        if !emailRegex.MatchString(strings.ToLower(email)) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid email format")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validatePassword(password string) error <span class="cov8" title="1">{
        if len(password) &lt; 8 </span><span class="cov8" title="1">{
                return fmt.Errorf("password must be at least 8 characters")
        }</span>
        <span class="cov8" title="1">if !regexp.MustCompile(`[A-Z]`).MatchString(password) </span><span class="cov8" title="1">{
                return fmt.Errorf("password must contain at least one uppercase letter")
        }</span>
        <span class="cov8" title="1">if !regexp.MustCompile(`[a-z]`).MatchString(password) </span><span class="cov8" title="1">{
                return fmt.Errorf("password must contain at least one lowercase letter")
        }</span>
        <span class="cov8" title="1">if !regexp.MustCompile(`[0-9]`).MatchString(password) </span><span class="cov8" title="1">{
                return fmt.Errorf("password must contain at least one number")
        }</span>
        <span class="cov8" title="1">if !regexp.MustCompile(`[!@#$%^&amp;*(),.?":{}|&lt;&gt;]`).MatchString(password) </span><span class="cov8" title="1">{
                return fmt.Errorf("password must contain at least one special character")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package db

import (
        "crypto/rand"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "log"
        mathrand "math/rand/v2"
        "os"
        "time"

        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
)

func InitDB() *gorm.DB <span class="cov0" title="0">{
        db, err := gorm.Open(sqlite.Open("blog.db"), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Run migrations
        <span class="cov0" title="0">err = db.AutoMigrate(&amp;Post{}, &amp;Tag{}, &amp;User{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return db</span>
}

func GetPosts(db *gorm.DB, limit int) ([]Post, error) <span class="cov0" title="0">{
        var posts []Post
        result := db.Preload("Tags").
                Where("published_at &lt;= ?", time.Now()).
                Where("visible = ?", true).
                Order("id desc").
                Limit(limit).
                Find(&amp;posts)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return posts, nil</span>
}

func GetPostBySlug(db *gorm.DB, slug string) (Post, error) <span class="cov0" title="0">{
        var post Post
        result := db.Preload("Tags").
                Where("slug = ?", slug).
                Where("published_at &lt;= ?", time.Now()).
                Where("visible = ?", true).
                First(&amp;post)
        if result.Error != nil </span><span class="cov0" title="0">{
                return post, result.Error
        }</span>
        <span class="cov0" title="0">return post, nil</span>
}

func GetUserByEmail(db *gorm.DB, email string) (*User, error) <span class="cov0" title="0">{
        var user User
        result := db.Where("email = ?", email).First(&amp;user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func CreateUser(db *gorm.DB, user *User) error <span class="cov0" title="0">{
        return db.Create(user).Error
}</span>

// New function to generate random session token
func generateSessionToken() (string, error) <span class="cov0" title="0">{
        b := make([]byte, 32)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.URLEncoding.EncodeToString(b), nil</span>
}

func GetUserByToken(db *gorm.DB, token string) (*User, error) <span class="cov0" title="0">{
        var user User
        result := db.Where("session_token = ?", token).First(&amp;user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func UpdateUserSessionToken(db *gorm.DB, user *User) error <span class="cov0" title="0">{
        token, err := generateSessionToken()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">user.SessionToken = token
        return db.Save(user).Error</span>
}

// Add helper function for random tag selection
func getRandomTags(tags []Tag, min, max int) []Tag <span class="cov0" title="0">{
        if len(tags) == 0 </span><span class="cov0" title="0">{
                return []Tag{}
        }</span>

        // Get random count between min and max
        <span class="cov0" title="0">count := min + mathrand.IntN(max-min+1)
        if count &gt; len(tags) </span><span class="cov0" title="0">{
                count = len(tags)
        }</span>

        // Shuffle tags
        <span class="cov0" title="0">shuffled := make([]Tag, len(tags))
        copy(shuffled, tags)
        mathrand.Shuffle(len(shuffled), func(i, j int) </span><span class="cov0" title="0">{
                shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
        }</span>)

        <span class="cov0" title="0">return shuffled[:count]</span>
}

type testData struct {
        Tags  []string   `json:"tags"`
        Posts []testPost `json:"posts"`
}

type testPost struct {
        Title       string `json:"title"`
        Slug        string `json:"slug"`
        Content     string `json:"content"`
        PublishedAt string `json:"publishedAt"`
        Visible     bool   `json:"visible"`
        Excerpt     string `json:"excerpt"`
}

func InsertTestData(db *gorm.DB) error <span class="cov0" title="0">{
        var count int64
        err := db.Model(&amp;Post{}).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                // Read test data
                data, err := os.ReadFile("data/test_posts.json")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var testData testData
                if err := json.Unmarshal(data, &amp;testData); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Create tags
                <span class="cov0" title="0">tags := make([]Tag, len(testData.Tags))
                for i, name := range testData.Tags </span><span class="cov0" title="0">{
                        tag := Tag{Name: name}
                        if err := db.FirstOrCreate(&amp;tag, Tag{Name: name}).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">tags[i] = tag</span>
                }

                // Create posts
                <span class="cov0" title="0">for _, p := range testData.Posts </span><span class="cov0" title="0">{
                        // Parse relative date
                        days := 0
                        if n, err := fmt.Sscanf(p.PublishedAt, "-%dd", &amp;days); err != nil || n != 1 </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid publishedAt format: %s", p.PublishedAt)
                        }</span>

                        <span class="cov0" title="0">post := Post{
                                Title:       p.Title,
                                Slug:        p.Slug,
                                Content:     p.Content,
                                PublishedAt: time.Now().AddDate(0, 0, -days),
                                Visible:     p.Visible,
                                Excerpt:     &amp;p.Excerpt,
                                Tags:        getRandomTags(tags, 2, 4),
                        }

                        if err := db.Create(&amp;post).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "time"

        "codeinstyle.io/captain/db"
        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

type AdminHandlers struct {
        db *gorm.DB
}

func NewAdminHandlers(database *gorm.DB) *AdminHandlers <span class="cov0" title="0">{
        return &amp;AdminHandlers{db: database}
}</span>

// ListTags shows all tags and their post counts
func (h *AdminHandlers) ListTags(c *gin.Context) <span class="cov0" title="0">{
        var tags []struct {
                db.Tag
                PostCount int64
        }

        result := h.db.Model(&amp;db.Tag{}).
                Select("tags.*, count(post_tags.post_id) as post_count").
                Joins("left join post_tags on post_tags.tag_id = tags.id").
                Group("tags.id").
                Find(&amp;tags)

        if result.Error != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusInternalServerError, "errors/500.tmpl", gin.H{})
                return
        }</span>

        <span class="cov0" title="0">c.HTML(http.StatusOK, "admin_tags.tmpl", gin.H{
                "title": "Tags",
                "tags":  tags,
        })</span>
}

// DeleteTag removes a tag without affecting posts
func (h *AdminHandlers) DeleteTag(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        if err := h.db.Delete(&amp;db.Tag{}, id).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete tag"})
                return
        }</span>
        <span class="cov0" title="0">c.Redirect(http.StatusFound, "/admin/tags")</span>
}

// ListUsers shows all users (except sensitive data)
func (h *AdminHandlers) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        var users []db.User
        if err := h.db.Select("id, first_name, last_name, email, created_at, updated_at").Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusInternalServerError, "errors/500.tmpl", gin.H{})
                return
        }</span>
        <span class="cov0" title="0">c.HTML(http.StatusOK, "admin_users.tmpl", gin.H{
                "title": "Users",
                "users": users,
        })</span>
}

// ShowCreatePost displays the post creation form
func (h *AdminHandlers) ShowCreatePost(c *gin.Context) <span class="cov0" title="0">{
        var tags []db.Tag
        if err := h.db.Find(&amp;tags).Error; err != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusInternalServerError, "errors/500.tmpl", gin.H{})
                return
        }</span>

        <span class="cov0" title="0">c.HTML(http.StatusOK, "admin_create_post.tmpl", gin.H{
                "title": "Create Post",
                "tags":  tags,
        })</span>
}

func (h *AdminHandlers) CreatePost(c *gin.Context) <span class="cov0" title="0">{
        var post db.Post

        // Parse form data
        title := c.PostForm("title")
        slug := c.PostForm("slug")
        content := c.PostForm("content")
        publishedAt := c.PostForm("publishedAt")
        visible := c.PostForm("visible") == "on"

        // Basic validation
        if title == "" || slug == "" || content == "" || publishedAt == "" </span><span class="cov0" title="0">{
                c.HTML(http.StatusBadRequest, "admin_create_post.tmpl", gin.H{
                        "error": "All fields are required",
                })
                return
        }</span>

        // Parse the published date
        <span class="cov0" title="0">parsedTime, err := time.Parse("2006-01-02T15:04", publishedAt)
        if err != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusBadRequest, "admin_create_post.tmpl", gin.H{
                        "error": "Invalid date format",
                })
                return
        }</span>

        // Create post object
        <span class="cov0" title="0">post = db.Post{
                Title:       title,
                Slug:        slug,
                Content:     content,
                PublishedAt: parsedTime,
                Visible:     visible,
        }

        // Handle tags
        var tagNames []string
        if err := json.Unmarshal([]byte(c.PostForm("tags")), &amp;tagNames); err != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusBadRequest, "admin/create_post.tmpl", gin.H{
                        "error": "Invalid tags format",
                        "post":  post,
                })
                return
        }</span>

        // Create/get tags and associate
        <span class="cov0" title="0">var tags []db.Tag
        for _, name := range tagNames </span><span class="cov0" title="0">{
                var tag db.Tag
                result := h.db.Where(db.Tag{Name: name}).FirstOrCreate(&amp;tag)
                if result.Error != nil </span><span class="cov0" title="0">{
                        c.HTML(http.StatusInternalServerError, "admin/create_post.tmpl", gin.H{
                                "error": "Failed to create tag",
                                "post":  post,
                        })
                        return
                }</span>
                <span class="cov0" title="0">tags = append(tags, tag)</span>
        }
        <span class="cov0" title="0">post.Tags = tags

        // Create post with transaction to ensure atomic operation
        tx := h.db.Begin()
        if err := tx.Create(&amp;post).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                c.HTML(http.StatusInternalServerError, "admin/create_post.tmpl", gin.H{
                        "error": "Failed to create post",
                        "post":  post,
                })
                return
        }</span>

        <span class="cov0" title="0">if err := tx.Model(&amp;post).Association("Tags").Replace(tags); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                c.HTML(http.StatusInternalServerError, "admin/create_post.tmpl", gin.H{
                        "error": "Failed to associate tags",
                        "post":  post,
                })
                return
        }</span>

        <span class="cov0" title="0">tx.Commit()
        c.Redirect(http.StatusFound, "/admin/posts")</span>
}

// ListPosts shows all posts for admin
func (h *AdminHandlers) ListPosts(c *gin.Context) <span class="cov0" title="0">{
        var posts []db.Post
        if err := h.db.Preload("Tags").Find(&amp;posts).Error; err != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusInternalServerError, "errors/500.tmpl", gin.H{})
                return
        }</span>
        <span class="cov0" title="0">c.HTML(http.StatusOK, "admin_posts.tmpl", gin.H{
                "title": "Posts",
                "posts": posts,
        })</span>
}

// ConfirmDeletePost shows deletion confirmation page
func (h *AdminHandlers) ConfirmDeletePost(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        var post db.Post
        if err := h.db.First(&amp;post, id).Error; err != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusNotFound, "errors/404.tmpl", gin.H{})
                return
        }</span>
        <span class="cov0" title="0">c.HTML(http.StatusOK, "admin_confirm_delete.tmpl", gin.H{
                "title": "Confirm Delete",
                "post":  post,
        })</span>
}

// DeletePost removes a post and its tag associations
func (h *AdminHandlers) DeletePost(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        // Start transaction
        tx := h.db.Begin()

        // Delete post_tags associations
        if err := tx.Exec("DELETE FROM post_tags WHERE post_id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                c.HTML(http.StatusInternalServerError, "errors/500.tmpl", gin.H{
                        "error": "Failed to delete post tags",
                })
                return
        }</span>

        // Delete post
        <span class="cov0" title="0">if err := tx.Delete(&amp;db.Post{}, id).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                c.HTML(http.StatusInternalServerError, "errors/500.tmpl", gin.H{
                        "error": "Failed to delete post",
                })
                return
        }</span>

        <span class="cov0" title="0">tx.Commit()
        c.Redirect(http.StatusFound, "/admin/posts")</span>
}

func (h *AdminHandlers) EditPost(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        var post db.Post

        if err := h.db.Preload("Tags").First(&amp;post, id).Error; err != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusNotFound, "errors/404.tmpl", gin.H{})
                return
        }</span>

        <span class="cov0" title="0">var allTags []db.Tag
        if err := h.db.Find(&amp;allTags).Error; err != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusInternalServerError, "errors/500.tmpl", gin.H{})
                return
        }</span>

        <span class="cov0" title="0">c.HTML(http.StatusOK, "admin_edit_post.tmpl", gin.H{
                "title":   "Edit Post",
                "post":    post,
                "allTags": allTags,
        })</span>
}

func (h *AdminHandlers) UpdatePost(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        var post db.Post

        if err := h.db.First(&amp;post, id).Error; err != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusNotFound, "errors/404.tmpl", gin.H{})
                return
        }</span>

        // Update fields
        <span class="cov0" title="0">post.Title = c.PostForm("title")
        post.Slug = c.PostForm("slug")
        post.Content = c.PostForm("content")
        post.Visible = c.PostForm("visible") == "on"

        publishedAt, err := time.Parse("2006-01-02T15:04", c.PostForm("publishedAt"))
        if err != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusBadRequest, "admin_edit_post.tmpl", gin.H{
                        "error": "Invalid date format",
                        "post":  post,
                })
                return
        }</span>
        <span class="cov0" title="0">post.PublishedAt = publishedAt

        // Handle tags
        var tagNames []string
        if err := json.Unmarshal([]byte(c.PostForm("tags")), &amp;tagNames); err != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusBadRequest, "admin_edit_post.tmpl", gin.H{
                        "error": "Invalid tags format",
                        "post":  post,
                })
                return
        }</span>

        // Update tags
        <span class="cov0" title="0">var tags []db.Tag
        for _, name := range tagNames </span><span class="cov0" title="0">{
                var tag db.Tag
                h.db.FirstOrCreate(&amp;tag, db.Tag{Name: name})
                tags = append(tags, tag)
        }</span>
        <span class="cov0" title="0">post.Tags = tags

        // Update with transaction
        tx := h.db.Begin()
        if err := tx.Save(&amp;post).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                c.HTML(http.StatusInternalServerError, "admin/edit_post.tmpl", gin.H{
                        "error": "Failed to update post",
                        "post":  post,
                })
                return
        }</span>

        <span class="cov0" title="0">if err := tx.Model(&amp;post).Association("Tags").Replace(tags); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                c.HTML(http.StatusInternalServerError, "admin/edit_post.tmpl", gin.H{
                        "error": "Failed to update tags",
                        "post":  post,
                })
                return
        }</span>

        <span class="cov0" title="0">tx.Commit()
        c.Redirect(http.StatusFound, "/admin/posts")</span>
}

func (h *AdminHandlers) Index(c *gin.Context) <span class="cov0" title="0">{
        var postCount, tagCount, userCount int64
        var recentPosts []db.Post

        // Get counts
        h.db.Model(&amp;db.Post{}).Count(&amp;postCount)
        h.db.Model(&amp;db.Tag{}).Count(&amp;tagCount)
        h.db.Model(&amp;db.User{}).Count(&amp;userCount)

        // Get 5 most recent posts
        h.db.Order("published_at desc").Limit(5).Find(&amp;recentPosts)

        data := gin.H{
                "title":       "Dashboard",
                "postCount":   postCount,
                "tagCount":    tagCount,
                "userCount":   userCount,
                "recentPosts": recentPosts,
        }

        data = h.addCommonData(c, data)

        c.HTML(http.StatusOK, "admin_index.tmpl", data)
}</span>

// Add response struct
type tagResponse struct {
        Id   uint   `json:"id"`   // lowercase for JS
        Name string `json:"name"` // lowercase for JS
}

func (h *AdminHandlers) GetTags(c *gin.Context) <span class="cov0" title="0">{
        var dbTags []db.Tag

        if err := h.db.Find(&amp;dbTags).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch tags"})
                return
        }</span>

        // Transform to response format
        <span class="cov0" title="0">tags := make([]tagResponse, len(dbTags))
        for i, tag := range dbTags </span><span class="cov0" title="0">{
                tags[i] = tagResponse{
                        Id:   tag.ID,
                        Name: tag.Name,
                }
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, tags)</span>
}

// handlers/admin.go
func (h *AdminHandlers) SavePreferences(c *gin.Context) <span class="cov0" title="0">{
        var prefs struct {
                Theme string `json:"theme"`
        }

        if err := c.BindJSON(&amp;prefs); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid preferences"})
                return
        }</span>

        // Save theme preference in cookie
        <span class="cov0" title="0">c.SetCookie("admin_theme", prefs.Theme, 3600*24*365, "/", "", false, false)
        c.JSON(http.StatusOK, gin.H{"status": "ok"})</span>
}

// Add to all admin handlers:
func (h *AdminHandlers) addCommonData(c *gin.Context, data gin.H) gin.H <span class="cov0" title="0">{
        if data == nil </span><span class="cov0" title="0">{
                data = gin.H{}
        }</span>

        <span class="cov0" title="0">theme, _ := c.Cookie("admin_theme")
        if theme == "" </span><span class="cov0" title="0">{
                theme = "light"
        }</span>

        <span class="cov0" title="0">data["theme"] = theme
        return data</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "net/http"

        "codeinstyle.io/captain/db"
        "codeinstyle.io/captain/utils"
        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

type AuthHandlers struct {
        db *gorm.DB
}

func NewAuthHandlers(database *gorm.DB) *AuthHandlers <span class="cov0" title="0">{
        return &amp;AuthHandlers{db: database}
}</span>

func (h *AuthHandlers) Login(c *gin.Context) <span class="cov0" title="0">{
        returnTo := c.Query("returnTo")
        if returnTo == "" </span><span class="cov0" title="0">{
                returnTo = "/admin"
        }</span>

        <span class="cov0" title="0">email := c.PostForm("email")
        password := c.PostForm("password")

        user, err := db.GetUserByEmail(h.db, email)
        if err != nil || !utils.CheckPasswordHash(password, user.Password) </span><span class="cov0" title="0">{
                c.HTML(http.StatusUnauthorized, "login.tmpl", gin.H{
                        "error":    "Invalid credentials",
                        "returnTo": returnTo,
                })
                return
        }</span>

        <span class="cov0" title="0">if err := db.UpdateUserSessionToken(h.db, user); err != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusInternalServerError, "500.tmpl", gin.H{})
                return
        }</span>

        <span class="cov0" title="0">c.SetCookie("session", user.SessionToken, 3600*24, "/", "", false, true)

        // Redirect to original destination
        c.Redirect(http.StatusFound, returnTo)</span>
}

func (h *AuthHandlers) Logout(c *gin.Context) <span class="cov0" title="0">{
        // Clear session cookie
        c.SetCookie("session", "", -1, "/", "", false, true)

        // Save theme preference before logout
        theme, _ := c.Cookie("admin_theme")

        c.Redirect(http.StatusFound, "/")

        // Restore theme after redirect is set
        if theme != "" </span><span class="cov0" title="0">{
                c.SetCookie("admin_theme", theme, 3600*24*365, "/", "", false, false)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "fmt"
        "math"
        "net/http"
        "strconv"

        "codeinstyle.io/captain/db"
        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

type PostHandlers struct {
        db *gorm.DB
}

func NewPostHandlers(database *gorm.DB) *PostHandlers <span class="cov0" title="0">{
        return &amp;PostHandlers{db: database}
}</span>

func (h *PostHandlers) GetPostBySlug(c *gin.Context) <span class="cov0" title="0">{
        slug := c.Param("slug")

        var post db.Post
        if err := h.db.Where("slug = ?", slug).First(&amp;post).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        c.HTML(http.StatusNotFound, "404.tmpl", gin.H{
                                "title": "Post not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.HTML(http.StatusInternalServerError, "500.tmpl", gin.H{
                        "title": "Error",
                })
                return</span>
        }

        <span class="cov0" title="0">c.HTML(http.StatusOK, "post.tmpl", gin.H{
                "title": post.Title,
                "post":  post,
        })</span>
}

func (h *PostHandlers) ListPosts(c *gin.Context) <span class="cov0" title="0">{
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        perPage := 3 // Posts per page

        var total int64
        h.db.Model(&amp;db.Post{}).Where("visible = ?", true).Count(&amp;total)

        totalPages := int(math.Ceil(float64(total) / float64(perPage)))
        offset := (page - 1) * perPage

        var posts []db.Post
        result := h.db.Preload("Tags").
                Where("visible = ?", true).
                Order("published_at desc").
                Offset(offset).
                Limit(perPage).
                Find(&amp;posts)

        if result.Error != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusInternalServerError, "500.tmpl", gin.H{})
                return
        }</span>

        <span class="cov0" title="0">c.HTML(http.StatusOK, "posts.tmpl", gin.H{
                "title":       "Latest Articles",
                "posts":       posts,
                "currentPage": page,
                "totalPages":  totalPages,
        })</span>
}

func (h *PostHandlers) ListPostsByTag(c *gin.Context) <span class="cov0" title="0">{
        tagName := c.Param("tag")
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        perPage := 3 // Posts per page

        // Get total count
        var total int64
        h.db.Model(&amp;db.Post{}).
                Joins("JOIN post_tags ON posts.id = post_tags.post_id").
                Joins("JOIN tags ON post_tags.tag_id = tags.id").
                Where("tags.name = ? AND posts.visible = ?", tagName, true).
                Count(&amp;total)

        totalPages := int(math.Ceil(float64(total) / float64(perPage)))
        offset := (page - 1) * perPage

        // Get posts
        var posts []db.Post
        result := h.db.Preload("Tags").
                Joins("JOIN post_tags ON posts.id = post_tags.post_id").
                Joins("JOIN tags ON post_tags.tag_id = tags.id").
                Where("tags.name = ? AND posts.visible = ?", tagName, true).
                Order("published_at desc").
                Offset(offset).
                Limit(perPage).
                Find(&amp;posts)

        if result.Error != nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusInternalServerError, "500.tmpl", gin.H{})
                return
        }</span>

        <span class="cov0" title="0">c.HTML(http.StatusOK, "tag_posts.tmpl", gin.H{
                "title":       fmt.Sprintf("Posts tagged with #%s", tagName),
                "tag":         tagName,
                "posts":       posts,
                "currentPage": page,
                "totalPages":  totalPages,
        })</span>
}

// ...other post handlers like GetPostBySlug, EditPost, etc...
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "net/http"

        "codeinstyle.io/captain/middleware"
        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

// RegisterPublicRoutes registers all public routes
func RegisterPublicRoutes(r *gin.Engine, database *gorm.DB) <span class="cov0" title="0">{
        postHandlers := NewPostHandlers(database)
        authHandlers := NewAuthHandlers(database) // Add this

        // Auth routes (public)
        r.GET("/login", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.HTML(http.StatusOK, "login.tmpl", gin.H{})
        }</span>)
        <span class="cov0" title="0">r.POST("/login", authHandlers.Login)
        r.GET("/", postHandlers.ListPosts)
        r.GET("/posts/:slug", postHandlers.GetPostBySlug)
        r.GET("/tags/:tag", postHandlers.ListPostsByTag)</span>
}

// RegisterAdminRoutes registers all admin routes
func RegisterAdminRoutes(r *gin.Engine, database *gorm.DB) <span class="cov0" title="0">{
        admin := r.Group("/admin")
        admin.Use(middleware.AuthRequired(database))

        adminHandlers := NewAdminHandlers(database)
        authHandlers := NewAuthHandlers(database) // Add this line

        // Add index route
        admin.GET("/", adminHandlers.Index)

        // Add logout route
        admin.GET("/logout", authHandlers.Logout)

        // Tag routes
        admin.GET("/tags", adminHandlers.ListTags)
        admin.DELETE("/tags/:id", adminHandlers.DeleteTag)

        // User routes
        admin.GET("/users", adminHandlers.ListUsers)

        // Post routes
        admin.GET("/new_post", adminHandlers.ShowCreatePost)
        admin.POST("/new_post", adminHandlers.CreatePost)
        admin.GET("/posts", adminHandlers.ListPosts)
        admin.GET("/posts/:id/delete", adminHandlers.ConfirmDeletePost)
        admin.DELETE("/posts/:id", adminHandlers.DeletePost)
        admin.GET("/posts/:id/edit", adminHandlers.EditPost)
        admin.POST("/posts/:id", adminHandlers.UpdatePost)
        admin.GET("/api/tags", adminHandlers.GetTags)

        // Preferences route
        admin.POST("/preferences", adminHandlers.SavePreferences)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "fmt"
        "log"
        "os"
        "text/template"

        "codeinstyle.io/captain/cli"
        "codeinstyle.io/captain/db"
        "codeinstyle.io/captain/handlers"
        "github.com/gin-gonic/gin"
        "github.com/spf13/cobra"
)

var (
        port      int
        host      string
        initDevDB bool
)

func main() <span class="cov0" title="0">{
        var rootCmd = &amp;cobra.Command{Use: "captain"}

        var runCmd = &amp;cobra.Command{
                Use:   "run",
                Short: "Runs the server",
                Run:   runServer,
        }

        runCmd.Flags().IntVarP(&amp;port, "port", "p", 8080, "Port to run the server on")
        runCmd.Flags().StringVarP(&amp;host, "bind", "b", "localhost", "Host to run the server on")
        runCmd.Flags().BoolVarP(&amp;initDevDB, "init-dev-db", "i", false, "Initialize the development database with test data")

        var userCmd = &amp;cobra.Command{
                Use:   "user",
                Short: "User management commands",
        }

        var userCreateCmd = &amp;cobra.Command{
                Use:   "create",
                Short: "Create a new user",
                Run:   cli.CreateUser,
        }

        var userUpdatePasswordCmd = &amp;cobra.Command{
                Use:   "update-password",
                Short: "Update user password",
                Run:   cli.UpdateUserPassword,
        }

        userCmd.AddCommand(userCreateCmd, userUpdatePasswordCmd)
        rootCmd.AddCommand(runCmd, userCmd)

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}

func runServer(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        database := db.InitDB()
        r := gin.Default()

        if initDevDB </span><span class="cov0" title="0">{
                err := db.InsertTestData(database)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to insert test data: %v\n", err)
                }</span>
        }

        // Serve static files
        <span class="cov0" title="0">r.Static("/static", "static")

        // Custom template functions
        r.SetFuncMap(template.FuncMap{
                "add": func(a, b int) int </span><span class="cov0" title="0">{
                        return a + b
                }</span>,
                "sub": func(a, b int) int <span class="cov0" title="0">{
                        return a - b
                }</span>,
        })

        // Load templates
        <span class="cov0" title="0">r.LoadHTMLGlob("templates/**/*")

        // Register routes
        handlers.RegisterPublicRoutes(r, database)

        handlers.RegisterAdminRoutes(r, database)

        fmt.Printf("Server running on http://%s:%d\n", host, port)
        r.Run(fmt.Sprintf("%s:%d", host, port))</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "net/http"

        "codeinstyle.io/captain/db"
        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

func AuthRequired(database *gorm.DB) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                token, err := c.Cookie("session")
                if err != nil || token == "" </span><span class="cov0" title="0">{
                        // Store requested URL and redirect to login
                        returnTo := c.Request.URL.String()
                        c.Redirect(http.StatusFound, "/login?returnTo="+returnTo)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">user, err := db.GetUserByToken(database, token)
                if err != nil </span><span class="cov0" title="0">{
                        c.SetCookie("session", "", -1, "/", "", false, true)
                        // Store requested URL and redirect to login
                        returnTo := c.Request.URL.String()
                        c.Redirect(http.StatusFound, "/login?returnTo="+returnTo)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Set("user", user)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package utils

import (
        "golang.org/x/crypto/bcrypt"
)

func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

func CheckPasswordHash(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
